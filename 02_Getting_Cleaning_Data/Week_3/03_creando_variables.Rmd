---
title: "Creando nuevas variables"
author: "Carlos Guadián"
output: 
  github_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Porqué crear nuevas variables?

- En la mayoría de ocasiones los datos originales no tienen el indicador que estamos buscando. 
- Por lo que habitualmente tendremos que transformar los datos de los que disponemos para obtener los valores deseados.
- Normalmente añadiremos estos nuevos indicadores al dataframe con el que estemos trabajando.
- Variables más comunes para crear:
  - Indicadores perdidos
  - Variables cuantitativas
  - Aplicando transformaciones
  
Vamos a volver a utilizar el dataset de los restaurantes de Baltimore, como en la anterior unidad.
```{r}
restData <- read.csv("./data/Restaurants.csv")
library(tibble)
restData <- as_tibble(restData)
```

## Creando secuencias
A veces necesitamos un índice para el dataset. Vamos a crear uno. Veamos tres maneras de crearlo con seq()
```{r}
s1 <- seq(1, 10, by =2)
s1
s2 <- seq(1, 10, length = 3)
s2
x <- c(1, 3, 8, 25, 100)
seq(along = x)
```

## Segmentando variables
Podemos crear una nueva variable segmentando una existente. Por ejemplo, creamos "nearMe" para los restaurantes que coincidan con "Roland Park" o "Homeland". La nueva variable contendrá TRUE o FALSE dependiendo si cumple la condición.
```{r}
restData$nearMe <- restData$nghbrhd %in% c("Roland Park", "Homeland")
table(restData$nearMe)
```

## Creando variables binarias
Podemos comprobar si el zipcode es correcto asignandolo a una nueva variable, en este caso todos son correctos.

Utilizamos ifelse() para decirle que si es mayor de 0, entonces es TRUE, sinó FALSE.
```{r warning=FALSE}
restData$zipWrong <- ifelse(as.numeric(restData$zipcode) < 0, TRUE, FALSE)
table(restData$zipWrong, restData$zipcode < 0)
```

## Creando variables categóricas
Puede que necesitemos crear una variable categórica en base a una cuantitativa. En este caso vamos a utilizar zipcode, que lo trataremos como "numérico" para poder generar la variable categórica en base a sus cuantiles.
```{r warning=FALSE}
restData$zipGroups <- cut(as.numeric(restData$zipcode), breaks = quantile(as.numeric(restData$zipcode), na.rm = TRUE))
table(restData$zipGroups)
```

Así la podemos utilizar para ver cuantos restaurantes hay por cada grupo y por su código postal.
```{r warning=FALSE}
table(restData$zipGroups, restData$zipcode)
```

Otra manera fácil de especificar los puntos de "corte" para generar una variable categórica es con Hmisc() aplicando cut2() y en "g" indicamos el número de grupos que queremos.
```{r warning=FALSE}
library(Hmisc)
restData$zipGroups <- cut2(as.numeric(restData$zipcode), g = 4)
table(restData$zipGroups)
```

## Creando factores
Respecto de los códigos postales, podemos tratarlos como si fueran factores, podemos hacer un tratamiento más adecuado que si es un valor numérico. Para ello utilizamos factor()
```{r warning=FALSE}
restData$zcf <- factor(restData$zipcode)
restData$zcf[1:10]
class(restData$zcf)
```

Respecto de los niveles de una variable factor, los niveles se generan por orden alfabético a no ser que indiquemos lo contrario. En este caso queremos que "yes" sea el valor más alto. Para ello utilizarmos relevel(), así si queremos utilizar la variable como número "yes" será 1 y "no" el 2.
```{r warning=FALSE}
yesno <- sample(c("yes", "no"), size = 10, replace = TRUE)
yesnofac <- factor(yesno, levels = c("yes", "no"))
relevel(yesnofac, ref = "yes")
as.numeric(yesnofac)
```

De la misma manera que antes hemos "cortado" una variable para hacer categorías.
```{r warning=FALSE}
library(Hmisc)
restData$zipGroups <- cut2(as.numeric(restData$zipcode), g = 4)
table(restData$zipGroups)
```

Con la función mutate() de la librería plyr() podemos añadir una nueva variable como factor.
```{r warning=FALSE}
library(Hmisc)
library(plyr)
restData2 <- mutate(restData, zipGroups = cut2(as.numeric(zipcode), g = 4))
table(restData2$zipGroups)
```

## Transformaciones más comunes

- abs(x) -> valor absoluto
- sqrt(x) -> raíz cuadrada
- ceiling(x) -> redondeo de números hacia arriba
- floor(x) -> redondeo de números hacia abajo
- round(x, digits = n) -> redondeo de digitos
- signif(x, digits = n) -> redondeo de digitos
- cos(x), sin(x), etc...
- log(x) -> logaritmo natural
- log2(x), log10(x) -> otros logaritmos habituales
- exp(x) -> exponenciales

Más info en 
- https://www.biostat.jhsph.edu/~ajaffe/lec_winterR/Lecture%202.pdf
- http://statmethods.net/management/functions.html
