---
title: "split"
author: Carlos Guadián
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## split
La función split() toma un vector u otros objetos y los divide en grupos determinados por un factor o lista de factores.

Los argumentos de split() son

```{r}
str(split)
```

Donde:

- x es un vector (o lista) o marco de datos
- f es un factor (o coaccionado a uno) o una lista de factores
- drop indica si los niveles de los factores vacíos deben ser descartados

La combinación de split() y una función como lapply() o sapply() es un paradigma común en R. 

La idea básica es que se puede tomar una estructura de datos, dividirla en subconjuntos definidos por otra variable, y aplicar una función sobre esos subconjuntos. Los resultados de la aplicación de la función sobre los subconjuntos se cotejan y se devuelven como un objeto. Esta secuencia de operaciones se denomina a veces "map-reduce" en otros contextos.

Generamos, como en tapply un vector con diferentes factores:

```{r}
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)
```

Y procedemos a dividirlo por cada uno de ellos:

```{r}
split(x, f)
```

Ahora si queremos aplicar a cada uno de esos grupos algún cálculo deberíamos utilizar lapply() o sapply(). Es algo bastante común utilizarlas conjuntamente con split().

```{r}
lapply(split(x, f), mean)
```

Obtenemos el mismo resultado con tapply()

```{r}
tapply(x, f, mean, simplify = FALSE)
```

## Splitting un Data Frame
split() se puede utilizar para dividir objetos más complicados como un data frame.

Vamos a cargar airquality para hacer unas pruebas.

```{r}
library(datasets)
head(airquality)
```

Primero vamos a dividirlo en meses. Obtenemos 5 dataframes, uno por mes.

```{r}
s <- split(airquality, airquality$Month)
```

Ahora podemos calcular la medias por columna de Ozone, Solar.R y Wind de cada dataframe.

```{r}
lapply(s, function(x) {
      colMeans(x[, c("Ozone", "Solar.R", "Wind")])
}) 
```

Aunque para una lectura más simplificada podemos utilizar sapply() y ya podemos forzar también dejar fuera los NA

```{r}
sapply(s, function(x) {
        colMeans(x[, c("Ozone", "Solar.R", "Wind")], 
                 na.rm = TRUE)
})
```

## Dividiendo en más de un nivel
Puede que queramos dividir un objeto de acuerdo a los niveles definidos en más de una variable. Esto lo podemos hacer con interaction()

```{r}
x <- rnorm(10)
f1 <- gl(2, 5)
f2 <- gl(5, 2)
f1
f2
## Create interaction of two factors
interaction(f1, f2)
```

Con múltiples factores y muchos niveles, la creación de una interacción puede dar lugar a niveles vacíos.

```{r}
str(split(x, list(f1, f2)))
```

Podemos evitar estos niveles vacíos con DROP

```{r}
str(split(x, list(f1, f2), drop = TRUE))
```