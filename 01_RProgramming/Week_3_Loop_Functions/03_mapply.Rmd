---
title: "mapply"
author: Carlos Guadián
output: 
  github_document:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## mapply
Aplica una función en paralalo con diferentes argumentos. En este caso lo primero que introducimos en mapply es la función.

Imaginemos que queremos una lista con 4 unos, 2 treses, 3 doses y 1 4. La podemos generar así:

```{r}
list(rep(1, 4), rep(2, 3), rep(3, 2), rep(4, 1)) 
```

O utilizando mapply:

```{r}
mapply(rep, 1:4, 4:1)
```

## Vectorización de una función
Otro ejemplo. Para la siguiente función que genera una distribución normal en base al número de números a generar teniendo en cuenta la media y la desviación estándar.

```{r}
noise <- function(n, mean, sd) {
      rnorm(n, mean, sd)
}
## Simulate 5 randon numbers
noise(5, 1, 2)
```

Ahora si pasamos como argumento dos vectores para generar diferentes sets de números, no funciona correctamente:

```{r}
noise(1:5, 1:5, 2)
```

Con mapply podemos conseguir 5 sets de números aleatorios con diferente longitud y media.

```{r}
mapply(noise, 1:5, 1:5, 2)
```

Lo que vendría a ser lo mismo que:

```{r}
list(noise(1, 1, 2), noise(2, 2, 2),
+      noise(3, 3, 2), noise(4, 4, 2),
+      noise(5, 5, 2))
```
